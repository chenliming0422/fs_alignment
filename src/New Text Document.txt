/*string dataFolder = "../../data/stack_test";
	int base = -130;
	const int stackSize = 2;
	int imageHeight = 1000;
	int imageWidth = 1280;
	int imageSize = imageHeight * imageWidth;

	vector<int>hSteps{ 9, 3, 3 };
	vector<int>vSteps{ 9, 3, 3 };
	const int totalSteps = 15;
	vector<int>hFringePeriods{ 36, 6 * 36, 1140 };
	vector<int>vFringePeriods{ 18, 8 * 18, 912 };
	vector<Mat> phaseMapStackH;
	vector<Mat> phaseMapStackV;
	vector<Mat> weightContrastH;
	vector<Mat> weightContrastV;
	vector<Mat> stackWarpH;
	vector<Mat> stackWarpV;
	CPhaseWrapUnwrap unwrap(imageWidth, imageHeight);

	vector<vector<Mat>> allImages;
	vector<Mat> oneStack;

	unsigned char* fringeImage[totalSteps];
	for (int i = 0; i < totalSteps; i++)
	{
		fringeImage[i] = new unsigned char[imageSize];
	}

	float* gammaH[stackSize];
	float* gammaV[stackSize];
	for (int i = 0; i < stackSize; i++)
	{
		gammaH[i] = new float[imageSize];
		gammaV[i] = new float[imageSize];
	}

	float* phaseLineH = new float[imageSize];
	float* phaseLineV = new float[imageSize];
	float* amplitudeH = new float[imageSize];
	float* amplitudeV = new float[imageSize];
	float* IavgH = new float[imageSize];
	float* IavgV = new float[imageSize];
	float* addContrast = new float[imageSize];

	// 1. read images
	for (int stackIdx = 0; stackIdx < stackSize; stackIdx++)
	{
		string stackPath = dataFolder + "/" + to_string(base-stackIdx) + ".00mA";
		for (int i = 0; i < totalSteps; i++)
		{
			string fileName = stackPath + "/" + to_string(i) + ".png";
			cout << fileName << endl;
			Mat image = imread(fileName, IMREAD_GRAYSCALE);
			oneStack.push_back(image.clone());
			memcpy(fringeImage[i], image.data, imageSize);
		}

		// 2. compute phase
		unwrap.unwrapThreeFreqPhaseLine(phaseLineH, fringeImage, hFringePeriods, hSteps, 7, IavgH, amplitudeH);
		unwrap.getFringeContrast(IavgH, amplitudeH, gammaH[stackIdx]);
		cout << phaseLineH[100] << endl;
		string phaseMapPath = stackPath + "/phaseMap_h.ph";
		write2DMap(phaseMapPath, phaseLineH, imageWidth, imageHeight);

		string gammaHMap = stackPath + "/gamma_h.ph";
		write2DMap(gammaHMap, gammaH[stackIdx], imageWidth, imageHeight);

		string amplitudeHMap = stackPath + "/amplitude_h.ph";
		write2DMap(amplitudeHMap, amplitudeH, imageWidth, imageHeight);

		for (int i = 0; i < totalSteps; i++)
		{
			string fileName = stackPath + "/" + to_string(i+totalSteps) + ".png";
			Mat image = imread(fileName, IMREAD_GRAYSCALE);
			oneStack.push_back(image.clone());
			memcpy(fringeImage[i], image.data, imageSize);
		}
		unwrap.unwrapThreeFreqPhaseLine(phaseLineV, fringeImage, vFringePeriods, vSteps, 7, IavgV, amplitudeV);
		unwrap.getFringeContrast(IavgV, amplitudeV, gammaV[stackIdx]);

		// store image and phase
		allImages.push_back(oneStack);
		oneStack.clear();
		Mat phaseH(imageHeight, imageWidth, CV_32FC1, phaseLineH);
		Mat phaseV(imageHeight, imageWidth, CV_32FC1, phaseLineV);
		phaseMapStackH.push_back(phaseH.clone());
		phaseMapStackV.push_back(phaseV.clone());
	}

	// get weight for ICIA
	for (int stackIdx = 0; stackIdx < stackSize - 1; stackIdx++)
	{
		unwrap.addFringeContrast(gammaH[stackIdx], gammaH[stackIdx+1], addContrast); 
		Mat contrastH(imageHeight, imageWidth, CV_32FC1, addContrast);
		weightContrastH.push_back(contrastH.clone());

		unwrap.addFringeContrast(gammaV[stackIdx], gammaV[stackIdx+1], addContrast);
		Mat contrastV(imageHeight, imageWidth, CV_32FC1, addContrast);
		weightContrastV.push_back(contrastV.clone());
		string stackPath = dataFolder + "/" + to_string(base - stackIdx) + ".00mA";
		string weightPath = stackPath + "/weight_h.ph";
		write2DMap(weightPath, (float *)contrastH.data, imageWidth, imageHeight);
	}
	*/
	//Mat warp;
	//weighted_inverse_compositional_align(phaseMapStackH[1], phaseMapStackH[0], weightContrastH[0], &warp);
	//weighted_inverse_compositional_align(phaseMapStackH[2], phaseMapStackH[1], weightContrastH[1], &warp);
	//vector<Mat> stack_warp;
	//align_image_stack(phaseMapStackH, weightContrastH, &stack_warp);